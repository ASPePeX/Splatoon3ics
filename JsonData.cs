// <auto-generated />
//
// To parse this JSON data, add NuGet 'System.Text.Json' then do:
//
//    using Splatoon3ics;
//
//    var splatData = SplatData.FromJson(jsonString);
#nullable enable
#pragma warning disable CS8618
#pragma warning disable CS8601
#pragma warning disable CS8603

namespace Splatoon3ics
{
    using System;
    using System.Collections.Generic;

    using System.Text.Json;
    using System.Text.Json.Serialization;
    using System.Globalization;

    public partial class SplatData
    {
        [JsonPropertyName("data")]
        public Data Data { get; set; }
    }

    public partial class Data
    {
        [JsonPropertyName("regularSchedules")]
        public Schedules RegularSchedules { get; set; }

        [JsonPropertyName("bankaraSchedules")]
        public Schedules BankaraSchedules { get; set; }

        [JsonPropertyName("xSchedules")]
        public Schedules XSchedules { get; set; }

        [JsonPropertyName("eventSchedules")]
        public EventSchedules EventSchedules { get; set; }

        [JsonPropertyName("festSchedules")]
        public Schedules FestSchedules { get; set; }

        [JsonPropertyName("coopGroupingSchedule")]
        public CoopGroupingSchedule CoopGroupingSchedule { get; set; }

        [JsonPropertyName("currentFest")]
        public object CurrentFest { get; set; }

        [JsonPropertyName("currentPlayer")]
        public CurrentPlayer CurrentPlayer { get; set; }

        [JsonPropertyName("vsStages")]
        public VsStages VsStages { get; set; }
    }

    public partial class Schedules
    {
        [JsonPropertyName("nodes")]
        public List<BankaraSchedulesNode> Nodes { get; set; }
    }

    public partial class BankaraSchedulesNode
    {
        [JsonPropertyName("startTime")]
        public DateTimeOffset StartTime { get; set; }

        [JsonPropertyName("endTime")]
        public DateTimeOffset EndTime { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("bankaraMatchSettings")]
        public List<MatchSetting> BankaraMatchSettings { get; set; }

        [JsonPropertyName("festMatchSettings")]
        public object FestMatchSettings { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("regularMatchSetting")]
        public MatchSetting RegularMatchSetting { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("xMatchSetting")]
        public MatchSetting XMatchSetting { get; set; }
    }

    public partial class MatchSetting
    {
        [JsonPropertyName("__isVsSetting")]
        public IsVsSetting IsVsSetting { get; set; }

        [JsonPropertyName("__typename")]
        public IsVsSetting Typename { get; set; }

        [JsonPropertyName("vsStages")]
        public List<Stage> VsStages { get; set; }

        [JsonPropertyName("vsRule")]
        public VsRule VsRule { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("bankaraMode")]
        public BankaraMode? BankaraMode { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("leagueMatchEvent")]
        public LeagueMatchEvent LeagueMatchEvent { get; set; }
    }

    public partial class LeagueMatchEvent
    {
        [JsonPropertyName("leagueMatchEventId")]
        public string LeagueMatchEventId { get; set; }

        [JsonPropertyName("name")]
        public string Name { get; set; }

        [JsonPropertyName("desc")]
        public string Desc { get; set; }

        [JsonPropertyName("regulationUrl")]
        public Uri RegulationUrl { get; set; }

        [JsonPropertyName("regulation")]
        public string Regulation { get; set; }

        [JsonPropertyName("id")]
        public string Id { get; set; }
    }

    public partial class VsRule
    {
        [JsonPropertyName("name")]
        public Name Name { get; set; }

        [JsonPropertyName("rule")]
        public Rule Rule { get; set; }

        [JsonPropertyName("id")]
        public Id Id { get; set; }
    }

    public partial class Stage
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("vsStageId")]
        public long? VsStageId { get; set; }

        [JsonPropertyName("name")]
        public string Name { get; set; }

        [JsonPropertyName("image")]
        public UserIcon Image { get; set; }

        [JsonPropertyName("id")]
        public string Id { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("thumbnailImage")]
        public UserIcon ThumbnailImage { get; set; }
    }

    public partial class UserIcon
    {
        [JsonPropertyName("url")]
        public Uri Url { get; set; }
    }

    public partial class CoopGroupingSchedule
    {
        [JsonPropertyName("bannerImage")]
        public object BannerImage { get; set; }

        [JsonPropertyName("regularSchedules")]
        public RegularSchedules RegularSchedules { get; set; }

        [JsonPropertyName("bigRunSchedules")]
        public Schedules BigRunSchedules { get; set; }

        [JsonPropertyName("teamContestSchedules")]
        public Schedules TeamContestSchedules { get; set; }
    }

    public partial class RegularSchedules
    {
        [JsonPropertyName("nodes")]
        public List<PurpleNode> Nodes { get; set; }
    }

    public partial class PurpleNode
    {
        [JsonPropertyName("startTime")]
        public DateTimeOffset StartTime { get; set; }

        [JsonPropertyName("endTime")]
        public DateTimeOffset EndTime { get; set; }

        [JsonPropertyName("setting")]
        public Setting Setting { get; set; }

        [JsonPropertyName("__splatoon3ink_king_salmonid_guess")]
        public string Splatoon3InkKingSalmonidGuess { get; set; }
    }

    public partial class Setting
    {
        [JsonPropertyName("__typename")]
        public string Typename { get; set; }

        [JsonPropertyName("coopStage")]
        public Stage CoopStage { get; set; }

        [JsonPropertyName("__isCoopSetting")]
        public string IsCoopSetting { get; set; }

        [JsonPropertyName("weapons")]
        public List<Weapon> Weapons { get; set; }
    }

    public partial class Weapon
    {
        [JsonPropertyName("__splatoon3ink_id")]
        public string Splatoon3InkId { get; set; }

        [JsonPropertyName("name")]
        public string Name { get; set; }

        [JsonPropertyName("image")]
        public UserIcon Image { get; set; }
    }

    public partial class CurrentPlayer
    {
        [JsonPropertyName("userIcon")]
        public UserIcon UserIcon { get; set; }
    }

    public partial class EventSchedules
    {
        [JsonPropertyName("nodes")]
        public List<EventSchedulesNode> Nodes { get; set; }
    }

    public partial class EventSchedulesNode
    {
        [JsonPropertyName("leagueMatchSetting")]
        public MatchSetting LeagueMatchSetting { get; set; }

        [JsonPropertyName("timePeriods")]
        public List<TimePeriod> TimePeriods { get; set; }
    }

    public partial class TimePeriod
    {
        [JsonPropertyName("startTime")]
        public DateTimeOffset StartTime { get; set; }

        [JsonPropertyName("endTime")]
        public DateTimeOffset EndTime { get; set; }
    }

    public partial class VsStages
    {
        [JsonPropertyName("nodes")]
        public List<VsStagesNode> Nodes { get; set; }
    }

    public partial class VsStagesNode
    {
        [JsonPropertyName("vsStageId")]
        public long VsStageId { get; set; }

        [JsonPropertyName("originalImage")]
        public UserIcon OriginalImage { get; set; }

        [JsonPropertyName("name")]
        public string Name { get; set; }

        [JsonPropertyName("stats")]
        public object Stats { get; set; }

        [JsonPropertyName("id")]
        public string Id { get; set; }
    }

    public enum BankaraMode { Challenge, Open };

    public enum IsVsSetting { BankaraMatchSetting, LeagueMatchSetting, RegularMatchSetting, XMatchSetting };

    public enum Id { VnNSdWxlLta, VnNSdWxlLte, VnNSdWxlLti, VnNSdWxlLtm, VnNSdWxlLtq };

    public enum Name { ClamBlitz, Rainmaker, SplatZones, TowerControl, TurfWar };

    public enum Rule { Area, Clam, Goal, Loft, TurfWar };

    public partial class SplatData
    {
        public static SplatData FromJson(string json) => JsonSerializer.Deserialize<SplatData>(json, Splatoon3ics.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this SplatData self) => JsonSerializer.Serialize(self, Splatoon3ics.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerOptions Settings = new(JsonSerializerDefaults.General)
        {
            Converters =
            {
                IsVsSettingConverter.Singleton,
                BankaraModeConverter.Singleton,
                IdConverter.Singleton,
                NameConverter.Singleton,
                RuleConverter.Singleton,
                new DateOnlyConverter(),
                new TimeOnlyConverter(),
                IsoDateTimeOffsetConverter.Singleton
            },
        };
    }

    internal class IsVsSettingConverter : JsonConverter<IsVsSetting>
    {
        public override bool CanConvert(Type t) => t == typeof(IsVsSetting);

        public override IsVsSetting Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "BankaraMatchSetting":
                    return IsVsSetting.BankaraMatchSetting;
                case "LeagueMatchSetting":
                    return IsVsSetting.LeagueMatchSetting;
                case "RegularMatchSetting":
                    return IsVsSetting.RegularMatchSetting;
                case "XMatchSetting":
                    return IsVsSetting.XMatchSetting;
            }
            throw new Exception("Cannot unmarshal type IsVsSetting");
        }

        public override void Write(Utf8JsonWriter writer, IsVsSetting value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case IsVsSetting.BankaraMatchSetting:
                    JsonSerializer.Serialize(writer, "BankaraMatchSetting", options);
                    return;
                case IsVsSetting.LeagueMatchSetting:
                    JsonSerializer.Serialize(writer, "LeagueMatchSetting", options);
                    return;
                case IsVsSetting.RegularMatchSetting:
                    JsonSerializer.Serialize(writer, "RegularMatchSetting", options);
                    return;
                case IsVsSetting.XMatchSetting:
                    JsonSerializer.Serialize(writer, "XMatchSetting", options);
                    return;
            }
            throw new Exception("Cannot marshal type IsVsSetting");
        }

        public static readonly IsVsSettingConverter Singleton = new IsVsSettingConverter();
    }

    internal class BankaraModeConverter : JsonConverter<BankaraMode>
    {
        public override bool CanConvert(Type t) => t == typeof(BankaraMode);

        public override BankaraMode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "CHALLENGE":
                    return BankaraMode.Challenge;
                case "OPEN":
                    return BankaraMode.Open;
            }
            throw new Exception("Cannot unmarshal type BankaraMode");
        }

        public override void Write(Utf8JsonWriter writer, BankaraMode value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case BankaraMode.Challenge:
                    JsonSerializer.Serialize(writer, "CHALLENGE", options);
                    return;
                case BankaraMode.Open:
                    JsonSerializer.Serialize(writer, "OPEN", options);
                    return;
            }
            throw new Exception("Cannot marshal type BankaraMode");
        }

        public static readonly BankaraModeConverter Singleton = new BankaraModeConverter();
    }

    internal class IdConverter : JsonConverter<Id>
    {
        public override bool CanConvert(Type t) => t == typeof(Id);

        public override Id Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "VnNSdWxlLTA=":
                    return Id.VnNSdWxlLta;
                case "VnNSdWxlLTE=":
                    return Id.VnNSdWxlLte;
                case "VnNSdWxlLTI=":
                    return Id.VnNSdWxlLti;
                case "VnNSdWxlLTM=":
                    return Id.VnNSdWxlLtm;
                case "VnNSdWxlLTQ=":
                    return Id.VnNSdWxlLtq;
            }
            throw new Exception("Cannot unmarshal type Id");
        }

        public override void Write(Utf8JsonWriter writer, Id value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case Id.VnNSdWxlLta:
                    JsonSerializer.Serialize(writer, "VnNSdWxlLTA=", options);
                    return;
                case Id.VnNSdWxlLte:
                    JsonSerializer.Serialize(writer, "VnNSdWxlLTE=", options);
                    return;
                case Id.VnNSdWxlLti:
                    JsonSerializer.Serialize(writer, "VnNSdWxlLTI=", options);
                    return;
                case Id.VnNSdWxlLtm:
                    JsonSerializer.Serialize(writer, "VnNSdWxlLTM=", options);
                    return;
                case Id.VnNSdWxlLtq:
                    JsonSerializer.Serialize(writer, "VnNSdWxlLTQ=", options);
                    return;
            }
            throw new Exception("Cannot marshal type Id");
        }

        public static readonly IdConverter Singleton = new IdConverter();
    }

    internal class NameConverter : JsonConverter<Name>
    {
        public override bool CanConvert(Type t) => t == typeof(Name);

        public override Name Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "Clam Blitz":
                    return Name.ClamBlitz;
                case "Rainmaker":
                    return Name.Rainmaker;
                case "Splat Zones":
                    return Name.SplatZones;
                case "Tower Control":
                    return Name.TowerControl;
                case "Turf War":
                    return Name.TurfWar;
            }
            throw new Exception("Cannot unmarshal type Name");
        }

        public override void Write(Utf8JsonWriter writer, Name value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case Name.ClamBlitz:
                    JsonSerializer.Serialize(writer, "Clam Blitz", options);
                    return;
                case Name.Rainmaker:
                    JsonSerializer.Serialize(writer, "Rainmaker", options);
                    return;
                case Name.SplatZones:
                    JsonSerializer.Serialize(writer, "Splat Zones", options);
                    return;
                case Name.TowerControl:
                    JsonSerializer.Serialize(writer, "Tower Control", options);
                    return;
                case Name.TurfWar:
                    JsonSerializer.Serialize(writer, "Turf War", options);
                    return;
            }
            throw new Exception("Cannot marshal type Name");
        }

        public static readonly NameConverter Singleton = new NameConverter();
    }

    internal class RuleConverter : JsonConverter<Rule>
    {
        public override bool CanConvert(Type t) => t == typeof(Rule);

        public override Rule Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            switch (value)
            {
                case "AREA":
                    return Rule.Area;
                case "CLAM":
                    return Rule.Clam;
                case "GOAL":
                    return Rule.Goal;
                case "LOFT":
                    return Rule.Loft;
                case "TURF_WAR":
                    return Rule.TurfWar;
            }
            throw new Exception("Cannot unmarshal type Rule");
        }

        public override void Write(Utf8JsonWriter writer, Rule value, JsonSerializerOptions options)
        {
            switch (value)
            {
                case Rule.Area:
                    JsonSerializer.Serialize(writer, "AREA", options);
                    return;
                case Rule.Clam:
                    JsonSerializer.Serialize(writer, "CLAM", options);
                    return;
                case Rule.Goal:
                    JsonSerializer.Serialize(writer, "GOAL", options);
                    return;
                case Rule.Loft:
                    JsonSerializer.Serialize(writer, "LOFT", options);
                    return;
                case Rule.TurfWar:
                    JsonSerializer.Serialize(writer, "TURF_WAR", options);
                    return;
            }
            throw new Exception("Cannot marshal type Rule");
        }

        public static readonly RuleConverter Singleton = new RuleConverter();
    }

    public class DateOnlyConverter : JsonConverter<DateOnly>
    {
        private readonly string serializationFormat;
        public DateOnlyConverter() : this(null) { }

        public DateOnlyConverter(string? serializationFormat)
        {
            this.serializationFormat = serializationFormat ?? "yyyy-MM-dd";
        }

        public override DateOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            return DateOnly.Parse(value!);
        }

        public override void Write(Utf8JsonWriter writer, DateOnly value, JsonSerializerOptions options)
            => writer.WriteStringValue(value.ToString(serializationFormat));
    }

    public class TimeOnlyConverter : JsonConverter<TimeOnly>
    {
        private readonly string serializationFormat;

        public TimeOnlyConverter() : this(null) { }

        public TimeOnlyConverter(string? serializationFormat)
        {
            this.serializationFormat = serializationFormat ?? "HH:mm:ss.fff";
        }

        public override TimeOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            return TimeOnly.Parse(value!);
        }

        public override void Write(Utf8JsonWriter writer, TimeOnly value, JsonSerializerOptions options)
            => writer.WriteStringValue(value.ToString(serializationFormat));
    }

    internal class IsoDateTimeOffsetConverter : JsonConverter<DateTimeOffset>
    {
        public override bool CanConvert(Type t) => t == typeof(DateTimeOffset);

        private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

        private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;
        private string? _dateTimeFormat;
        private CultureInfo? _culture;

        public DateTimeStyles DateTimeStyles
        {
            get => _dateTimeStyles;
            set => _dateTimeStyles = value;
        }

        public string? DateTimeFormat
        {
            get => _dateTimeFormat ?? string.Empty;
            set => _dateTimeFormat = (string.IsNullOrEmpty(value)) ? null : value;
        }

        public CultureInfo Culture
        {
            get => _culture ?? CultureInfo.CurrentCulture;
            set => _culture = value;
        }

        public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
        {
            string text;


            if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
                || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
            {
                value = value.ToUniversalTime();
            }

            text = value.ToString(_dateTimeFormat ?? DefaultDateTimeFormat, Culture);

            writer.WriteStringValue(text);
        }

        public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            string? dateText = reader.GetString();

            if (string.IsNullOrEmpty(dateText) == false)
            {
                if (!string.IsNullOrEmpty(_dateTimeFormat))
                {
                    return DateTimeOffset.ParseExact(dateText, _dateTimeFormat, Culture, _dateTimeStyles);
                }
                else
                {
                    return DateTimeOffset.Parse(dateText, Culture, _dateTimeStyles);
                }
            }
            else
            {
                return default(DateTimeOffset);
            }
        }


        public static readonly IsoDateTimeOffsetConverter Singleton = new IsoDateTimeOffsetConverter();
    }
}
#pragma warning restore CS8618
#pragma warning restore CS8601
#pragma warning restore CS8603
